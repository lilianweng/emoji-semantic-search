from pandas._typing import T as T

from typing import Any, Collection, Iterable, Optional, Union, Callable, Tuple, TypeVar, overload

class SettingWithCopyError(ValueError): ...
class SettingWithCopyWarning(Warning): ...

def flatten(l: Any) -> None: ...
def consensus_name_attr(objs: Any) -> Any: ...
def maybe_box(indexer: Any, values: Any, obj: Any, key: Any) -> Any: ...
def maybe_box_datetimelike(value: Any) -> Any: ...

values_from_object: Any

def is_bool_indexer(key: Any) -> bool: ...
def cast_scalar_indexer(val: Any) -> Any: ...
def not_none(*args: Any) -> Any: ...
def any_none(*args: Any) -> Any: ...
def all_none(*args: Any) -> Any: ...
def any_not_none(*args: Any) -> Any: ...
def all_not_none(*args: Any) -> Any: ...
def count_not_none(*args: Any) -> Any: ...
def try_sort(iterable: Any) -> Any: ...
def asarray_tuplesafe(values: Any, dtype: Optional[Any] = ...) -> Any: ...
def index_labels_to_array(labels: Any, dtype: Optional[Any] = ...) -> Any: ...
def maybe_make_list(obj: Any) -> Any: ...
def maybe_iterable_to_list(obj: Union[Iterable[T], T]) -> Union[Collection[T], T]: ...
def is_null_slice(obj: Any) -> Any: ...
def is_true_slices(l: Any) -> Any: ...
def is_full_slice(obj: Any, l: Any) -> Any: ...
def get_callable_name(obj: Any) -> Any: ...
def apply_if_callable(maybe_callable: Any, obj: Any, **kwargs: Any) -> Any: ...
def dict_compat(d: Any) -> Any: ...
def standardize_mapping(into: Any) -> Any: ...
def random_state(state: Optional[Any] = ...) -> Any: ...
def get_rename_function(mapper: Any) -> Any: ...

PipeReturn = TypeVar("PipeReturn")
@overload
def pipe(obj: Any, func: Union[Callable[..., PipeReturn], Tuple[Callable[..., PipeReturn], str]], *args: Any, **kwargs: Any) -> PipeReturn: ...
@overload
def pipe(obj: Any, func: PipeReturn, *args: Any, **kwargs: Any) -> PipeReturn: ...
