# Removed some imports that were necessary only for implementation
import numpy as np

from pandas.core import algorithms as algorithms
from pandas.core.accessor import PandasDelegate as PandasDelegate
from pandas.core.arrays import DatetimeArray as DatetimeArray, ExtensionArray as ExtensionArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays.datetimelike import DatetimeLikeArrayMixin as DatetimeLikeArrayMixin
from pandas.core.dtypes.generic import ABCIndex as ABCIndex, ABCIndexClass as ABCIndexClass, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexes.base import Index as Index
from pandas.core.indexes.extension import ExtensionIndex as ExtensionIndex
from pandas.core.indexes.numeric import Int64Index as Int64Index
from pandas.core.ops import get_op_result_name as get_op_result_name
from pandas.core.tools.timedeltas import to_timedelta as to_timedelta
from pandas.errors import AbstractMethodError as AbstractMethodError
from pandas.tseries.frequencies import DateOffset as DateOffset, to_offset as to_offset
from pandas.util._decorators import Appender as Appender, cache_readonly as cache_readonly
from typing import Any, List, Optional

class DatetimeIndexOpsMixin(ExtensionIndex):
    freq: Optional[DateOffset]
    freqstr: Optional[str]
    hasnans: Any = ...
    date: np.ndarray
    @property
    def is_all_dates(self) -> bool: ...
    @property
    def values(self) -> Any: ...
    def __array_wrap__(self, result: Any, context: Optional[Any] = ...) -> Any: ...
    def equals(self, other: Any) -> bool: ...
    def __contains__(self, key: Any) -> Any: ...
    def sort_values(self, return_indexer: bool = ..., ascending: bool = ...) -> Any: ...
    def take(self, indices: Any, axis: int = ..., allow_fill: bool = ..., fill_value: Optional[Any] = ..., **kwargs: Any) -> Any: ...
    def tolist(self) -> List[Any]: ...
    def min(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any) -> Any: ...
    def argmin(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any) -> Any: ...
    def max(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any) -> Any: ...
    def argmax(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any) -> Any: ...
    __add__: Any = ...
    __radd__: Any = ...
    __sub__: Any = ...
    __rsub__: Any = ...
    __pow__: Any = ...
    __rpow__: Any = ...
    __mul__: Any = ...
    __rmul__: Any = ...
    __floordiv__: Any = ...
    __rfloordiv__: Any = ...
    __mod__: Any = ...
    __rmod__: Any = ...
    __divmod__: Any = ...
    __rdivmod__: Any = ...
    __truediv__: Any = ...
    __rtruediv__: Any = ...
    def isin(self, values: Any, level: Optional[Any] = ...) -> Any: ...
    def where(self, cond: Any, other: Optional[Any] = ...) -> Any: ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ...) -> Any: ...
    def delete(self, loc: Any) -> Any: ...

class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
    def difference(self, other: Any, sort: Optional[Any] = ...) -> Any: ...
    def intersection(self, other: Any, sort: bool = ...) -> Any: ...
    def join(self, other: Any, how: str=..., level: Any = ..., return_indexers: Any = ..., sort: Any = ...) -> Any: ...

class DatetimelikeDelegateMixin(PandasDelegate): ...
