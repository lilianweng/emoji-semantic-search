import numpy as np
from pandas._libs.tslibs import  resolution as resolution
from pandas.core.accessor import delegate_names as delegate_names
from pandas.core.arrays.period import PeriodArray as PeriodArray, period_array as period_array, raise_on_incompatible as raise_on_incompatible, validate_dtype_freq as validate_dtype_freq
from pandas.core.dtypes.common import ensure_platform_int as ensure_platform_int, is_bool_dtype as is_bool_dtype, is_datetime64_any_dtype as is_datetime64_any_dtype, is_dtype_equal as is_dtype_equal, is_float as is_float, is_float_dtype as is_float_dtype, is_integer as is_integer, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, pandas_dtype as pandas_dtype
from pandas.core.indexes.base import ensure_index as ensure_index, maybe_extract_name as maybe_extract_name
from pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin as DatetimeIndexOpsMixin, DatetimelikeDelegateMixin as DatetimelikeDelegateMixin
from pandas.core.indexes.datetimes import DatetimeIndex as DatetimeIndex, Index as Index
from pandas.core.indexes.numeric import Int64Index as Int64Index
from pandas.core.missing import isna as isna
from pandas.core.ops import get_op_result_name as get_op_result_name
from pandas.tseries import frequencies as frequencies
from pandas.tseries.offsets import DateOffset as DateOffset, Tick as Tick
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly
from typing import Any, Optional

class PeriodDelegateMixin(DatetimelikeDelegateMixin): ...

class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
    def __new__(cls, data: Optional[Any] = ..., ordinal: Optional[Any] = ..., freq: Optional[Any] = ..., tz: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., name: Optional[Any] = ..., **fields: Any) -> Any: ...
    @property
    def values(self) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray: ...
    def __array_wrap__(self, result: Any, context: Optional[Any] = ...) -> Any: ...
    def asof_locs(self, where: Any, mask: Any) -> Any: ...
    def astype(self, dtype: Any, copy: bool = ..., how: str = ...) -> Any: ...
    def searchsorted(self, value: Any, side: str = ..., sorter: Optional[Any] = ...) -> Any: ...
    @property
    def is_full(self) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    def get_value(self, series: Any, key: Any) -> Any: ...
    def get_indexer(self, target: Any, method: Optional[Any] = ..., limit: Optional[Any] = ..., tolerance: Optional[Any] = ...) -> Any: ...
    def get_indexer_non_unique(self, target: Any) -> Any: ...
    def get_loc(self, key: Any, method: Optional[Any] = ..., tolerance: Optional[Any] = ...) -> Any: ...
    def insert(self, loc: Any, item: Any) -> Any: ...
    def join(self, other: Any, how: str = ..., level: Optional[Any] = ..., return_indexers: bool = ..., sort: bool = ...) -> Any: ...
    def intersection(self, other: Any, sort: bool = ...) -> Any: ...
    def difference(self, other: Any, sort: Optional[Any] = ...) -> Any: ...
    def memory_usage(self, deep: bool = ...) -> Any: ...

def period_range(start: Any = ..., end: Any = ..., periods: Any = ..., freq: Any = ..., name: Any = ...) -> PeriodIndex: ...
