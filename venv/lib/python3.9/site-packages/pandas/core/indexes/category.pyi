# Removed some imports that were necessary only for implementation
import numpy as np
from pandas._typing import AnyArrayLike as AnyArrayLike, GeneralDuplicatesKeepStrategy
from pandas.core import accessor as accessor
from pandas.core.algorithms import take_1d as take_1d
from pandas.core.arrays.categorical import Categorical as Categorical, contains as contains
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype
from pandas.core.dtypes.generic import ABCCategorical as ABCCategorical, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexes.base import Index as Index, maybe_extract_name as maybe_extract_name
from pandas.core.indexes.extension import ExtensionIndex as ExtensionIndex, inherit_names as inherit_names
from pandas.core.ops import get_op_result_name as get_op_result_name
from pandas.util._decorators import Appender as Appender, cache_readonly as cache_readonly
from typing import Any, Optional

class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
    codes: np.ndarray
    categories: Index
    def __new__(cls, data: Optional[Any] = ..., categories: Optional[Any] = ..., ordered: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., name: Optional[Any] = ...) -> Any: ...
    def equals(self, other: Any) -> Any: ...
    @property
    def inferred_type(self) -> str: ...
    @property
    def values(self) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray: ...
    def astype(self, dtype: Any, copy: bool = ...) -> Any: ...
    def fillna(self, value: Any, downcast: Optional[Any] = ...) -> Any: ... # type: ignore
    def is_unique(self) -> bool: ...
    @property
    def is_monotonic_increasing(self) -> Any: ...
    @property
    def is_monotonic_decreasing(self) -> bool: ...
    def unique(self, level: Optional[Any] = ...) -> Any: ...
    def duplicated(self, keep: GeneralDuplicatesKeepStrategy = ...) -> Any: ...
    def get_loc(self, key: Any, method: Optional[Any] = ...) -> Any: ... # type: ignore
    def get_value(self, series: AnyArrayLike, key: Any) -> Any: ...
    def where(self, cond: Any, other: Optional[Any] = ...) -> Any: ...
    def reindex(self, target: Any, method: Optional[Any] = ..., level: Optional[Any] = ..., limit: Optional[Any] = ..., tolerance: Optional[Any] = ...) -> Any: ...
    def get_indexer(self, target: Any, method: Optional[Any] = ..., limit: Optional[Any] = ..., tolerance: Optional[Any] = ...) -> Any: ...
    def get_indexer_non_unique(self, target: Any) -> Any: ...
    def take_nd(self, *args: Any, **kwargs: Any) -> Any: ...
    def map(self, mapper: Any) -> Any: ...  # type: ignore
    def delete(self, loc: Any) -> Any: ...
    def insert(self, loc: Any, item: Any) -> Any: ...
