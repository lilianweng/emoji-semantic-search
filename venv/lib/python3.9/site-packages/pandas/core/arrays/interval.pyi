import numpy as np
from pandas._config import get_option as get_option
from pandas._libs.interval import Interval as Interval, IntervalMixin as IntervalMixin, intervals_to_interval_bounds as intervals_to_interval_bounds
from pandas.core.algorithms import take as take, value_counts as value_counts
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.categorical import Categorical as Categorical
from pandas.core.construction import array as array
from pandas.core.dtypes.cast import maybe_convert_platform as maybe_convert_platform

from pandas.core.dtypes.dtypes import IntervalDtype as IntervalDtype
from pandas.core.dtypes.generic import ABCDatetimeIndex as ABCDatetimeIndex, ABCExtensionArray as ABCExtensionArray, ABCIndexClass as ABCIndexClass, ABCInterval as ABCInterval, ABCIntervalIndex as ABCIntervalIndex, ABCPeriodIndex as ABCPeriodIndex, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna, notna as notna

from pandas.core.indexes.base import ensure_index as ensure_index
from pandas.util._decorators import Appender as Appender
from typing import Any, Optional

class IntervalArray(IntervalMixin, ExtensionArray):
    ndim: int = ...
    can_hold_na: bool = ...
    def __new__(cls, data: Any, closed: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., verify_integrity: bool = ...) -> Any: ...
    @classmethod
    def from_breaks(cls, breaks: Any, closed: str = ..., copy: bool = ..., dtype: Optional[Any] = ...) -> Any: ...
    @classmethod
    def from_arrays(cls, left: Any, right: Any, closed: str = ..., copy: bool = ..., dtype: Optional[Any] = ...) -> Any: ...
    @classmethod
    def from_tuples(cls, data: Any, closed: str = ..., copy: bool = ..., dtype: Optional[Any] = ...) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __getitem__(self, value: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ...) -> Any: ...
    @property
    def dtype(self) -> Any: ...
    def astype(self, dtype: Any, copy: bool = ...) -> Any: ...
    def copy(self) -> Any: ...
    def isna(self) -> Any: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def size(self) -> int: ...
    def shift(self, periods: int=..., fill_value: object=...) -> ABCExtensionArray: ...
    def take(self, indices: Any, allow_fill: bool = ..., fill_value: Optional[Any] = ..., axis: Optional[Any] = ..., **kwargs: Any) -> Any: ...
    def value_counts(self, dropna: bool = ...) -> Any: ...
    @property
    def left(self) -> Any: ...
    @property
    def right(self) -> Any: ...
    @property
    def closed(self) -> Any: ...
    def set_closed(self, closed: Any) -> Any: ...
    @property
    def length(self) -> Any: ...
    @property
    def mid(self) -> Any: ...
    @property
    def is_non_overlapping_monotonic(self) -> Any: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray: ...
    def __arrow_array__(self, type: Optional[Any] = ...) -> Any: ...
    def to_tuples(self, na_tuple: bool = ...) -> Any: ...
    def repeat(self, repeats: Any, axis: Optional[Any] = ...) -> Any: ...
    def contains(self, other: Any) -> Any: ...
    def overlaps(self, other: Any) -> Any: ...

def maybe_convert_platform_interval(values: Any) -> Any: ...
